# 第15章 面向对象程序设计
面向对象的程序设计(OOP)
## 15.1 OOP:概述
面向对象程序设计的核心思想是数据抽象、继承和动态绑定。
* 通过使用数据抽象，我们可以将类的接口和实现分离；
* 使用继承，可以定义相似的类型并对其相似关系建模
* 使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象

#### 继承
通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类，其他类则直接或间接从基类继承而来，这些继承得到的类称为派生类。

在C++ 中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成**虚函数** **virtual function**
```C++
class Quote{
    public:
    string isbn() const;
    virtual double net_price(size_t n) const;
};
```
派生类 必须通过使用类派生列表明确指出它是从哪个基类继承而来的。
类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符:
```C++
class Bulk_quote:public Quote{
    public:
        double net_price(std::size_t) const override;
};
```
因为Bulk_quote在它的派生列表中使用了public关键字，我们完全可以把Bulk_quote的对象当成Quote的对象来使用

派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上 **virtual** 关键字。
> C++11 新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表后面增加一个override关键字

#### 动态绑定
函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时候又被称为运行时绑定。
> 在C++ 语言中，当我们使用基类的引用(或指针)调用一个虚函数时将发生动态绑定。

## 15.2 定义基类和派生类
### 15.2.1 定义基类
> 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

#### 成员函数与继承
派生类需要对这些操作提供自己的新定义以覆盖(override)从基类继承而来的旧定义。
在C++中，基类必须将它的两种成员函数区分开来:
1. 一种是基类希望其派生类进行覆盖的函数
2. 另一种是 基类希望派生类直接继承而不要改变的函数。
   
对于1，基类通常定义为虚函数。任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。

#### 访问控制与继承
