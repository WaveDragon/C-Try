# 第16章 模板与泛型编程
## 16.1 定义模板
假如要编写函数比较两个类型的值，实际要为每个类型编写
### 16.1.1 函数模板
模板定义以关键字 **template** 开始，后跟一个模板参数列表，这是一个逗号分隔的一个或多个模板参数的列表，用<>包围
模板参数列表不能为空
#### 实例化函数模板
当调用一个函数模板时，编译器通常用函数实参来为我们推断模板实参。
即，调用compare时，根据实参类型推断T为int
```C++
template <typename T>
int compare(const T &v1,const T &v2)
{
    if (v1 < v2) return -1;
    if (v1 > v2) return 1;
    return 0;
}   
cout << compare(1,0) << endl;
```
编译器生成的版本通常被称为模板的实例
#### 模板类型参数
```C++
template <typename T>
T foo(T* p)
{
    T tmp = *p;
    return tmp;
}
template <typename T,class U>....
typename与class含义相同，可以交换使用。
```
#### 非类型模板参数
一个非类型参数表示一个值而非一个类型。
当一个模板被实例化，非类型参数被编译器推断出的值所代替。
例如：
第一个模板参数表示第一个数组的长度，第二个表示第二个数组长度
```C++
template<unsigned N,unsigned M>
int compare(const char (&p1)[N],const char (&p1)[M])
{
    returen strcmp(p1,p2);
}
compare("hi","mom");
编译器实例化N和M
```
> 非类型模板参数的模板实参必须时常量表达式

#### inline和constexpr的函数模板
inline和constexpr放在模板参数列表之后，返回类型之前:
#### 编写类型无关的代码
> 模板程序应该尽量减少对实参类型的要求。

#### 模板编译
当编译器遇到一个模板定义时，它并不生成代码，只有我们实例化出模板的一个特定版本时，编译器才会生成代码。
> 函数模板和类模板成员函数的定义通常放在头文件中
> 类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中
### 16.1.2 类模板
定义类模板
#### 实例化类模板
显式模板实参
Blob<int> ia;
> 一个类模板的每个实例都形成一个对立的类。
#### 在模板作用域中引用模板类型
#### 
